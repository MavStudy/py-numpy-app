# NumPy - Произведение матриц и векторов, элементы линейной алгебры
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def array_info(name, arr):
    print(
        f"массив {name}:",
        type(arr),
        id(arr),
        arr.shape
    )


def main():
    # Умножение вектора на матрицу
    #
    # Умножение_вектора_на_матрицу.png
    #

    # Это также можно записать двумя способами.
    # Для реализации первого способа, зададим одномерный вектор
    # и двумерную матрицу:
    a = np.array([1, 2, 3])
    array_info('a', a)
    print(a)
    # массив a: <class 'numpy.ndarray'> 2330961998064 (3,)
    # [1 2 3]

    separator()

    b = np.arange(4, 10).reshape(3, 2)  # матрица 3х2
    array_info('b', b)
    print(b)
    # массив b: <class 'numpy.ndarray'> 2331099668304 (3, 2)
    # [[4 5]
    #  [6 7]
    #  [8 9]]

    separator()

    # И, затем, воспользуемся уже знакомой нам функцией dot:
    print(np.dot(a, b))
    # [40 46]
    # 1 * 4 + 2 * 6 + 3 * 8 = 4 + 12 + 24 = 40
    # 1 * 5 + 2 * 7 + 3 * 9 = 5 + 14 + 27 = 46

    separator()

    # При такой записи, когда одномерный массив записан первым аргументом,
    # а матрица – вторым, получаем умножение вектора-строки на матрицу,
    # то есть, первый способ.

    # Для реализации второго способа аргументы нужно поменять местами:
    # сначала указать матрицу, а затем, вектор. Но, если мы сейчас это сделаем
    # с нашими массивами, то получим ошибку:
    #
    # np.dot(b, b)  # несогласованность размеров
    #
    # ValueError: shapes (3,2) and (3,2) not aligned: 2 (dim 1) != 3 (dim 0)

    # Дело в том, что массив a должен представлять вектор длиной два элемента,
    # так как матрица b имеет размер в 3 строки и 2 столбца:
    #
    #  Согласованность_размеров.png

    # Определим массивa в два элемента и умножим на матрицу b:
    a = np.array([1, 2])
    array_info('a', a)
    print(a)
    separator()
    print(np.dot(b, a))
    # [14 20 26]
    # 4 * 1 + 5 * 2 = 4 + 10 = 14
    # 6 * 1 + 7 * 2 = 6 + 14 = 20
    # 8 * 1 + 9 * 2 = 8 + 18 = 26

    # Получаем вектор-строку (одномерный массив) как результат умножения.
    # Обратите внимание, по правилам математики вектор aдолжен быть
    # вектором-столбцом, то есть, быть представленным в виде:
    #
    a.shape = -1, 1  # вектор-столбец 2х1

    # Но мы использовали вектор-строку. В NumPyтак тоже можно делать и это
    # не приведет к ошибке. Результат будет именно умножение матрицы как бы
    # на вектор-столбец. Ну а если использовать вектор-столбец, то и на выходе
    # получим вектор-столбец:

    print(np.dot(b, a))
    # [[14]
    #  [20]
    #  [26]]

    separator()

    # Этого же результат можно достичь, используя
    # оператор @ (перегрузка функции matmul):
    print(b @ a)  # вектор-столбец 3х1
    # [[14]
    #  [20]
    #  [26]]

    # Результат будет тем же. Вот так в NumPy выполняется
    # умножение матриц, векторов и вектора на матрицу.


if __name__ == '__main__':
    main()
