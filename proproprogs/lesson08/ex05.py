# NumPy - базовые математические операции над массивами
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def array_info(name, arr):
    print(
        f"массив {name}:",
        type(arr),
        id(arr),
        arr.shape
    )


def main():
    # Все представленные математические операции имеют следующие
    # расширенные аналоги:
    # ------------------------
    # a += b   | a = a + b
    # a -= b   | a = a - b
    # a * b    | a = a * b
    # a / b    | a = a / b
    # a // b   | a = a // b
    # a ** b   | a = a ** b
    # a % b    | a = a % b
    # ------------------------
    # То есть, если нам нужно произвести какие-либо математические операции
    # с массивом и изменения сохранить в нем же, то удобно использовать такие
    # сокращенные записи. Выполняются они очевидным образом, например, так:
    a = np.array([1, 2, 6, 8])
    array_info('a', a)
    print(a)
    # массив a: <class 'numpy.ndarray'> 31043920 (4,)
    # [1 2 6 8]
    a += 5
    separator()
    array_info('a', a)
    print(a)
    # массив a: <class 'numpy.ndarray'> 31043920 (4,)
    # [ 6  7 11 13]
    separator()
    b = np.ones(4)
    array_info('b', b)
    print(b)
    # массив b: <class 'numpy.ndarray'> 41966640 (4,)
    # [1. 1. 1. 1.]
    separator()
    b *= a
    array_info('b', b)
    print(b)

    # И так далее. Но есть один нюанс работы этих операторов. Если, например,
    # массив b определить с типом данных float64:
    #
    # b = np.ones(4, dtype='float64')
    #
    # а массив a имеет тип int32 (можно посмотреть через свойство a.dtype),
    # то операция:
    #
    # a += b
    #
    # приведет к ошибке. С чем это связано? Дело в том, что результатом
    # сложения вещественного числа с целочисленным, итоговое значение
    # представляет собой вещественное число. Но тип данных массива a –
    # целочисленный и он не может сохранять вещественные числа. Отсюда
    # и возникает эта ошибка. Вообще, следует помнить правило:
    #
    # -------------------------------------------------------------------------
    # При выполнении арифметических операций тип данных автоматически
    # приводится к более общему.
    # -------------------------------------------------------------------------
    #
    # То есть, при работе с целочисленными и вещественными числами на выходе
    # получаем вещественные. При работе с вещественными и комплексными –
    # комплексные. И так далее. Всегда результатом имеем более общий тип
    # данных.
    #
    # Все описанные математические операции можно комбинировать и записывать
    # в виде:
    #
    # (a + b) * 5 - 10
    #
    # Здесь круглые скобки, как и в математике, операция изменения приоритетов,
    # то есть, сначала будет выполнено сложение, затем, умножение и в последнюю
    # очередь вычитание.
    #
    # Вот так работают и используются базовые математические операции в пакете
    # NumPy при работе с массивами.


if __name__ == '__main__':
    main()
