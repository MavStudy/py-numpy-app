# NumPy - базовые математические операции над массивами
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def array_info(name, arr):
    print(
        f"массив {name}:",
        type(arr),
        id(arr),
        arr.shape
    )


def main():
    # Теперь, когда мы знаем как формировать массивы пришло время самого
    # главного, самого важно для чего, собственно, и был разработан пакет
    # NumPy – к рассмотрению его математических, вычислительных возможностей.
    # И в основе своей эти вычисления базируются на матрицах и векторах. Но,
    # обо всем по порядку и вначале поговорим о базовых математических
    # операциях этого пакета.

    # Предположим, имеется обычный список и массив, созданный на его основе:
    lst = [1, 2, 3]
    a = np.array([1, 2, 3])
    print(f"{id(lst)=}")
    print(lst)
    array_info('a', a)
    print(a)

    separator()

    # Сейчас вы увидите принципиальную разницу между двумя этими объектами.
    # Умножим их на число 2:
    lst = lst * 2
    a = a * 2
    print(f"{id(lst)=}")
    print(lst)
    array_info('a', a)
    print(a)

    # Видите, при умножении списка языка Python, он дублируется дважды, а при
    # умножении на NumPy массив – каждый его элемент умножается математически
    # на число 2. Если бы мы захотели то же самое реализовать непосредственно
    # на Python, оперируя списками, то пришлось бы делать что-то вроде:
    # [x * 2 for x in lst]
    #
    # Но выполнялась бы такая конструкция дольше, чем в случае с массивом
    # NumPy. Именно благодаря удобству и скорости библиотека NumPy и приобрела
    # свою популярность.


if __name__ == '__main__':
    main()
