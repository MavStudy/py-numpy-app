# NumPy - Множества (unique) и операции над ними
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def array_info(name, arr):
    print(
        f"массив {name}:",
        type(arr),
        id(arr),
        arr.shape
    )


def main():
    # На этом занятии познакомимся с еще одним типом математических операций
    # пакета NumPy – работы со множествами. И ответим на первый вопрос:
    # что такое множество с позиции NumPy?

    # предположим имеется одномерный массив:
    a = np.array([1, 2, 3, 4, 4, 3, 2, 1])
    array_info('a', a)
    print(a)
    # массив a: <class 'numpy.ndarray'> 1901610720816 (8,)
    # [1 2 3 4 4 3 2 1]

    separator()

    # В нем есть неуникальные (повторяющиеся) значения. Так вот,
    # в множествах все значения должны быть уникальными и представленными
    # в единственном варианте.
    # Чтобы преобразовать массив a в множество используется функция unique:
    setA = np.unique(a)
    array_info('setA', setA)
    print(setA)
    # массив setA: <class 'numpy.ndarray'> 1642806386608 (4,)
    # [1 2 3 4]

    # В действительности это такой же массив, только с уникальными значениями.

    separator()

    # У функции unique есть несколько полезных параметров.
    # Первый из них return_counts:
    print(np.unique(a, return_counts=True))
    # (array([1, 2, 3, 4]), array([2, 2, 2, 2], dtype=int64))

    # который позволяет возвращать не только уникальные значения,
    # но и число их вхождений в исходном массиве a.

    separator()

    # Следующий параметр return_index позволяет определять индексы первого
    # вхождения уникальных элементов в исходном массиве:
    print(np.unique(a, return_index=True))
    # (array([1, 2, 3, 4]), array([0, 1, 2, 3], dtype=int64))

    separator()

    # Наконец, третий параметр return_inverse возвращает индексы, по которым
    # можно точно восстановить исходный массив. Понять этот параметр проще
    # всего на примере:
    print(np.unique(a, return_inverse=True))
    # (array([1, 2, 3, 4]), array([0, 1, 2, 3, 3, 2, 1, 0], dtype=int64))

    # Видите, здесь 1 у множества имеет индекс 0 и во втором массиве стоят нули
    # там, где должна быть 1. И так для всех значений. Далее, по этой информации
    # можно выполнить восстановление исходного массива a. Делается это так:
    setA, indx = np.unique(a, return_inverse=True)
    aa = setA[indx]  # восстановленный массив
    array_info('aa', aa)
    print(aa)
    # массив aa: <class 'numpy.ndarray'> 2255699648432 (8,)
    # [1 2 3 4 4 3 2 1]

    separator()

    # Подробнее о таком списочном индексировании мы поговорим
    # на следующем занятии.


if __name__ == '__main__':
    main()
