# NumPy - Индексация, срезы, итерирование массивов
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def array_info(name, arr):
    print(
        f"массив {name}:",
        type(arr),
        id(arr),
        arr.shape
    )


def main():
    # Списочная индексация и многомерные массивы
    #
    # Фактически, массив индексов определяет значения и форму создаваемого
    # массива. Например, если взять тот же одномерный массив:
    a = np.arange(1, 9)
    array_info('a', a)
    print(a)
    # массив a: <class 'numpy.ndarray'> 31961808 (8,)
    # [1 2 3 4 5 6 7 8]
    separator()

    # но набор индексов определить как двумерный массив:
    i = np.array([[0, 1], [2, 3]])

    # то на выходе будет формироваться уже двумерный массив:
    b = a[i]  # array([[1, 2], [3, 4]])
    array_info('b', b)
    print(b)
    # массив b: <class 'numpy.ndarray'> 161778160 (2, 2)
    # [[1 2]
    #  [3 4]]
    separator()

    # олько в этом случае индексы i должны определяться именно массивом NumPy,
    # а не списком Python.

    # Так можно создавать массивы любых размерностей. Давайте теперь посмотрим,
    # как будет себя вести списочное индексирование с многомерными массивами.
    # Возьмем двумерный массив:

    c = np.arange(1, 13).reshape(3, 4)
    array_info('c', c)
    print(c)
    # массив c: <class 'numpy.ndarray'> 161774352 (3, 4)
    # [[ 1  2  3  4]
    #  [ 5  6  7  8]
    #  [ 9 10 11 12]]
    separator()

    # и одномерный список индексов:
    indx = [2, 1, 0]
    d = c[indx]
    array_info('d', d)
    print(d)
    # массив d: <class 'numpy.ndarray'> 161770544 (3, 4)
    # [[ 9 10 11 12]
    #  [ 5  6  7  8]
    #  [ 1  2  3  4]]

    separator()
    # Смотрите, здесь индексы обозначают номера строк двумерного массива.
    # В результате, строки нового массива идут в обратном порядке. Далее,
    # пропишем индексы в виде двумерного массива:

    indx = np.array([[1, 0], [2, 1]])
    e = c[indx]
    array_info('e', e)
    print(e)
    # массив e: <class 'numpy.ndarray'> 161770448 (2, 2, 4)
    # [[[ 5  6  7  8]
    #   [ 1  2  3  4]]
    #
    #  [[ 9 10 11 12]
    #   [ 5  6  7  8]]]

    # Что здесь произошло? В действительности, каждый индекс двумерного массива
    # соответствует определенной строке этого массива. А двумерная форма
    # индексов лишь указывает как упаковать строки в новом массиве. То есть,
    # вместо каждого индекса подставляется своя строка и получается трехмерный
    # массив.

    separator()

    # Если же мы хотим выбирать из двумерного массива не строки, а отдельные
    # элементы и на их основе формировать новые массивы, то следует
    # использовать два списка. Первый список по прежнему будет указывать строки
    # массива, а второй – индексы столбцов у каждой строки. Например, так:
    i0 = [0, 1]
    i1 = [1, 2]
    f = c[i0, i1]  # array([2, 7])
    array_info('f', f)
    print(f)
    # массив f: <class 'numpy.ndarray'> 161774928 (2,)
    # [2 7]

    separator()

    # При множественной списочной индексации допускается указывать конкретные
    # индексы и срезы. Например:
    g = c[:, i1]  # В этом случае получим уже матрицу 3x2, то есть, второй
    # список i1 здесь используется для выделения столбцов целиком, а не одного
    # только элемента.
    array_info('g', g)
    print(g)
    # массив e: <class 'numpy.ndarray'> 161775120 (3, 2)
    # [[ 2  3]
    #  [ 6  7]
    #  [10 11]]

    separator()

    # Соответственно, строчка:
    h = c[i0, 1]  # array([2, 6])
    array_info('h', h)
    print(h)
    # массив h: <class 'numpy.ndarray'> 161775216 (2,)
    # [2 6]

    separator()



if __name__ == '__main__':
    main()
