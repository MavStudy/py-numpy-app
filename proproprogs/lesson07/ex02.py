# NumPy - Индексация, срезы, итерирование массивов
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def main():
    # Индексация и срезы многомерных массивов
    #
    # В базовом варианте индексация и срезы многомерных массивов работают также
    # как и в одномерных, только индексы указываются для каждой оси. Например,
    # объявим двумерный массив:
    x = np.array([(1, 2, 3), (10, 20, 30), (100, 200, 300)])
    print(
        "массив x:",
        type(x),
        id(x),
        x.shape
    )
    print(x)

    separator()

    # Для обращения к центральному значению 20 нужно выбрать вторую строку
    # и второй столбец, имеем:
    print(x[1, 1])  # значение 20

    # Чтобы взять последнюю строку и последний столбец, можно использовать
    # отрицательные индексы:
    print(x[-1, -1])  # значение 300

    # Если же указать только один индекс, то получим строку:
    print(x[0])  # [1 2 3]

    # Эта запись эквивалентна следующей:
    print(x[0, :])  # [1 2 3]
    # То есть, не указывая какие-либо индексы, NumPy
    # автоматически подставляет вместо них полные срезы.

    # Для извлечения столбцов мы уже должны явно указать полный срез
    # в качестве первого индекса:
    print(x[:, 1])  # [  2  20 200]

    separator()

    # Итерирование двумерных массивов можно выполнять с помощью
    # вложенных циклов, например:
    for row in x:
        for val in row:
            print(val, end=' ')
        print()
    # 1 2 3
    # 10 20 30
    # 100 200 300

    separator()

    # Если же необходимо просто перебрать все элементы многомерного массива,
    # то можно использовать свойство flat:
    for val in x.flat:
        print(val, end=' ')
    # 1 2 3 10 20 30 100 200 300

    #  массивов более высокой размерности картина индексации, в целом выглядит
    #  похожим образом. Например, создадим четырехмерный массив:
    a = np.arange(1, 82).reshape(3, 3, 3, 3)
    print(
        "массив a:",
        type(a),
        id(a),
        a.shape
    )
    print(a)

    separator()

    # Тогда для обращения к конкретному элементу следует указывать
    # четыре индекса:
    print(f"{a[1, 2, 0, 1]=}")

    # Для выделения многомерного среза, можно использовать такую запись:
    a1 = a[:, 1, :, :]  # матрица 3х3х3
    print(
        "массив a1:",
        type(a1),
        id(a1),
        a1.shape
    )
    print(a1)
    # массив a1: <class 'numpy.ndarray'> 2455042940848 (3, 3, 3)
    # [[[10 11 12]
    #   [13 14 15]
    #   [16 17 18]]
    #
    #   [[37 38 39]
    #    [40 41 42]
    #    [43 44 45]]
    #
    #   [[64 65 66]
    #    [67 68 69]
    #    [70 71 72]]]

    separator()

    # или так:
    a2 = a[0, 0]  # двумерная матрица 3х3
    # Это эквивалентно записи:
    # a[0, 0, :, :]
    print(
        "массив a2:",
        type(a2),
        id(a2),
        a2.shape
    )
    print(a2)
    # массив a2: <class 'numpy.ndarray'> 2455042940752 (3, 3)
    # [[1 2 3]
    #  [4 5 6]
    # [7 8 9]]

    separator()

    # Если же нужно задать два последних индекса, то полные срезы у первых двух
    # осей указывать обязательно:
    a3 = a[:, :, 1, 1]  # матрица 3х3
    print(
        "массив a3:",
        type(a3),
        id(a3),
        a3.shape
    )
    print(a3)
    # массив a3: <class 'numpy.ndarray'> 2088655790192 (3, 3)
    # [[ 5 14 23]
    #  [32 41 50]
    #  [59 68 77]]

    separator()

    a4 = a[0:2, 0:2, 1, 1]  # матрица 2х2
    print(
        "массив a4:",
        type(a4),
        id(a4),
        a4.shape
    )
    print(a4)
    # массив a4: <class 'numpy.ndarray'> 2755553287824 (2, 2)
    # [[ 5 14]
    #  [32 41]]

    # Пакет NumPy позволяет множество полных подряд идущих срезов заменять
    # троеточиями. Например, вместо a[:, :, 1, 1] можно использовать запись:
    a5 = a[..., 1, 1]  # эквивалент a[:, :, 1, 1]
    print(
        "массив a5:",
        type(a5),
        id(a5),
        a5.shape
    )
    print(a5)
    # массив a5: <class 'numpy.ndarray'> 2620767559600 (3, 3)
    # [[ 5 14 23]
    #  [32 41 50]
    #  [59 68 77]]

    # Это бывает удобно, когда у массива много размерностей и нам нужны
    # последние индексы.


if __name__ == '__main__':
    main()
