# NumPy - Индексация, срезы, итерирование массивов
import numpy as np


def separator(sep='-'):
    print(sep * 70)


def array_info(name, arr):
    print(
        f"массив {name}:",
        type(arr),
        id(arr),
        arr.shape
    )


def main():
    # Списочная индексация
    #
    # Помимо указания у массивов обычных индексов или срезов в NumPy существует
    # еще один способ индексирования – через списки или массивы целых чисел.
    # Чтобы лучше понять, о чем идет речь, рассмотрим этот механизм на
    # примерах. Для простоты возьмем одномерный массив с какими-нибудь
    # значениями:
    a = np.arange(1, 9)
    array_info('a', a)
    print(a)
    # массив a: <class 'numpy.ndarray'> 31764816 (8,)
    # [1 2 3 4 5 6 7 8]

    separator()

    # алее, смотрите, если указать обычный числовой индекс, то получим одно
    # значение соответствующего элемента:
    print(a[0])  # значение 1

    separator()

    # Но, если вместо числового индекса указать список:
    b = a[[0]]  # то на выходе уже получим копию массива из одного первого
    # значения исходного.
    array_info('b', b)
    print(b)
    # массив b: <class 'numpy.ndarray'> 161769776 (1,)
    # [1]

    separator()

    # То есть, выполняя далее операцию:
    b[0] = 100  # Изменение массива b не приведет к изменению данных
    # в массиве a.
    array_info('b', b)
    print(b)
    array_info('a', a)
    print(a)

    separator()

    # А что будет, если в списке указать несколько индексов? Например, так:
    a1 = a[[0, 1, 7, 5]]  # [1 2 8 6]
    array_info('a1', a1)
    print(a1)
    # массив a1: <class 'numpy.ndarray'> 161774160 (4,)
    # [1 2 8 6]
    # На выходе получаем новый массив, состоящий из соответствующих значений.

    separator()

    # Или, можно сделать даже так:
    a2 = a[[0, 0, 1, 1, 1, 2, 3, 4, 5, 6, 7]]
    array_info('a2', a2)
    print(a2)
    # массив a2: <class 'numpy.ndarray'> 161770352 (11,)
    # [1 1 2 2 2 3 4 5 6 7 8]

    # То есть, мы здесь имеем, фактически, способ формирования новых массивов
    # на основе других массивов. В списке достаточно перечислить индексы нужных
    # элементов и на выходе формируется массив с соответствующими значениями.
    # В ряде случаев такая операция бывает очень удобной.

    separator()

    # Но здесь есть один важный нюанс. Копия массива через списочное
    # индексирование создается, когда выражение записано справа от бинарного
    # оператора (является выражением типа rvalue). Если же такую же конструкцию
    # записать слева от оператора (как выражение lvalue), например,
    # присваивания:
    a[[0, 1, 2]] = [10, 20, 30]
    array_info('a', a)
    print(a)

    separator()

    # Кроме обычных списков языка Python мы можем передавать и массивы NumPy,
    # состоящие из целых значений. Например, так:
    indx = np.array(([0, 0, 1, 1, 1, 2]))
    c1 = a[indx]  # array([10, 10, 20, 20, 20, 30])
    array_info('c1', c1)
    print(c1)
    # массив c1: <class 'numpy.ndarray'> 161770352 (6,)
    # [10 10 20 20 20 30]

    separator()

    # Или, с булевыми значениями:
    bIndx = [True, True, False, False, False, True, False, False]
    c2 = a[bIndx]  # array([10, 20, 6])
    array_info('c2', c2)
    print(c2)
    # массив c2: <class 'numpy.ndarray'> 161770544 (3,)
    # [10 20  6]

    separator()

    # В результате останутся только те элементы, которым соответствуют индексы
    # True. Причем, длина списка (или массива) bIndx должна совпадать с длиной
    # массива a, иначе произойдет ошибка.
    #
    # Последний вариант списочной индексации используется очень часто.
    # Например, мы можем сформировать массив индексов путем какой-либо булевой
    # операции над массивом:
    i = a > 9  # array([True, True, True, False, False, False, False])

    # А, затем, использовать его, чтобы оставить только нужные элементы:
    c3 = a[i]  # array([10, 20, 30])
    array_info('c3', c3)
    print(c3)
    # массив c3: <class 'numpy.ndarray'> 161778640 (3,)
    # [10 20 30]

    # Или, все это можно записать короче в одну строчку:
    c4 = a[a > 9]
    array_info('c4', c4)
    print(c4)

    separator()


if __name__ == '__main__':
    main()
