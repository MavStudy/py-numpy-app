# Свойства и представления массивов, создание их копий
import numpy as np


def main():
    b = np.ones((3, 4, 5))
    print(b)
    print(f"Тип элемента массива: {b.dtype}")
    print(f"Количество элементов в массиве: {b.size}")
    print(f"Размер элемента массива в байтах: {b.itemsize}")
    print(f"Размер всего массива в байтах: {b.size * b.itemsize}")

    # Узнать количество его осей, можно через свойство ndim
    # (доступно только для чтения):
    print(f"Количество осей: {b.ndim}")

    # Чтобы определить размеры каждой из осей, используется свойство shape:
    print(f"Размерность осей: {b.shape}")  # вернёт кортеж (3, 4, 5)

    # С помощью свойства shape мы можем менять размерность массива, главное,
    # чтобы общее число элементов оставалось прежним.
    # Например, сделать так:
    b.shape = 60  # все 60 элементов вытянутся в троку
    print(b)
    print(f"Тип элемента массива: {b.dtype}")
    print(f"Количество элементов в массиве: {b.size}")
    print(f"Размер элемента массива в байтах: {b.itemsize}")
    print(f"Размер всего массива в байтах: {b.size * b.itemsize}")

    print(f"Количество осей: {b.ndim}")
    print(f"Размерность осей: {b.shape}")

    b.shape = (12, 5)  # массив размерностью 12x5
    print(b)
    print(f"id(b): {id(b)}")
    print(f"Тип элемента массива: {b.dtype}")
    print(f"Количество элементов в массиве: {b.size}")
    print(f"Размер элемента массива в байтах: {b.itemsize}")
    print(f"Размер всего массива в байтах: {b.size * b.itemsize}")

    print(f"Количество осей: {b.ndim}")
    print(f"Размерность осей: {b.shape}")

    # Такое весьма полезное и гибкое поведение влечет некоторые следствия.
    # Например, мы хотим сформировать новый массив на основе массива b, просто
    # изменив его форму (представление):

    c = b.reshape(3, 2, 10)
    # Мы здесь воспользовались методом reshape, который возвращает массив
    # с новой указанной размерностью (прежний массив остается без изменений).
    # В результате переменная c будет ссылаться на массив размерами 3x2x10,
    # а переменная b – на массив 12x5. Но данные при этом, будут
    # использоваться одни и те же:

    print(c)
    print(f"id(c): {id(c)}")
    print(f"Тип элемента массива: {c.dtype}")
    print(f"Количество элементов в массиве: {c.size}")
    print(f"Размер элемента массива в байтах: {c.itemsize}")
    print(f"Размер всего массива в байтах: {c.size * b.itemsize}")

    print(f"Количество осей: {c.ndim}")
    print(f"Размерность осей: {c.shape}")

    b[0, 0] = 10
    print(b)
    print(c)
    # Это связано с тем, что они ссылаются на разные представления одного
    # и того же массива, а не на его данные. То есть, пример функции reshape()
    # показывает, что в пакете NumPy разделяются понятия данные и
    # представление этих данных. В результате, одни и те же данные могут иметь
    # множество разных представлений. Это очень удобно с точки зрения экономии
    # памяти, когда один и тот же массив можно использовать и как одномерный
    # вектор и как матрицу.

    print("-" * 30)

    # Также при работе с NumPy следует помнить, что представления могут
    # формироваться разными способами. Метод reshape() – это лишь один частный
    # пример. Если выполнить транспонирование матрицы b и использовать для
    # этого свойство T:
    d = b.T  # T - транспонирование матрицы (12, 5)
    print(d.shape)  # возвратит кортеж (5, 12)
    print(id(d))
    print(d)
    print(b.shape)
    print(id(b))
    print(b)

if __name__ == '__main__':
    main()
